# -*- coding: utf-8 -*-
"""GLC.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eow5eGIhsCTBtdNRksXWcsGYXP78LbAX
"""

import nltk

def parse_grammar(text):
    """
    Parse a given text using the predefined context-free grammar (CFG) and
    check its validity.

    This function uses NLTK's ChartParser to parse the text according to a
    specified CFG. If the text conforms to the grammar, it prints a message
    and the parse trees; otherwise, it indicates that the text is not valid.

    Args:
        text (str): The text to be parsed.

    Returns:
        None
    """

    # Define the grammar using NLTK's CFG fromstring method
    grammar = nltk.CFG.fromstring("""
        MT -> MS SPS VN SC IN CSS
        CSS -> CS CSS | CS DC
        CS -> CST SPS VN SC IN CD | CST SPS VN SPS SC IN CD | CST SPS NM SC IN CD | CST SPS NM SPS SC IN CD
        DC -> CST SPS US SC IN CD | CST SPS US SPS SC IN CD
        CD -> PNT PR CM EN CMM PL IN | VN SPS EQ SPS NM IN | VN SPS EQ SPS CM EN CMM IN | MT
        EN -> VN | VN SP EN
        VN -> LT VS | US VS | LT | US
        VS -> LT VS | LT | NM VS | NM | US VS | US | EP
        TBS -> TB TBS | TB
        TB -> SP SP SP SP
        IN -> NL TBS
        SPS -> SP SPS | SP
        LT -> "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z"
        NM -> "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
        MS -> "m" "a" "t" "c" "h"
        CST -> "c" "a" "s" "e"
        PNT -> "p" "r" "i" "n" "t"
        SP -> " "
        SC -> ":" | SPS ":"
        NL -> "~"
        US -> "_"
        EQ -> "=" | SPS "=" SPS
        EP -> ""
        PR -> "("
        PL -> ")"
        CM -> "'"
        CMM -> "'"
    """)

    # Initialize the parser with the given grammar
    parser = nltk.ChartParser(grammar)
    # Replace newline characters with the '~' symbol as per the grammar
    # definition
    text = text.replace('\n', '~')

    try:
        # Attempt to parse the tokenized text
        trees = list(parser.parse([*text]))

        # Check if any parse trees were generated
        if trees:
            print("The text provided is valid. LL(1) parsing:")
            # Print each parse tree
            for tree in trees:
                tree.pretty_print()
        else:
            print("The text provided is not valid. Unable to parse.")
    except ValueError:
        print("The text provided is not valid. Unable to parse.")

# First test case to show the tree of the grammar parser.
# Expected behaviour.
# Output:  "The text provided is valid. LL(1) parsing:"
#           and the LL1 parsing tree
text_init = """match v:
    case 1:
        v = 1
    case _:
        v = 2
        """

parse_grammar(text_init)

# Case 0: This test case parses and validates an input text that contains
#         multiple nested match-case blocks. Each block contains at least
#         one pattern and a default pattern.
# Expected behaviour.
# Output:  "The text provided is valid. LL(1) parsing:"
#           and the LL1 parsing tree
text0 = """match _var_name1:
    case 1:
        match varName2:
            case 1:
                match varName2:
                    case 1:
                        var = 'Hola Mundo'
                    case _:
                        print('Adios')
            case _:
                print('Adios')
    case 2:
        var = 'Hola Mundo'
    case 3:
        var = 0
    case _:
        print('Hola Benji')
        """

parse_grammar(text0)

# Case 1: This test case parses and validates an input text that contains
#         multiple cases. Each case contains a call to a print function
#         with a string inside parentheses and surrounded by colons.
# Expected behaviour.
# Output:  "The text provided is valid. LL(1) parsing:"
#           and the LL1 parsing tree
test_case1 = """match var_1:
    case 1:
        print('Path one')
    case 2:
        print('Path two')
    case _:
        print('Default')
        """

parse_grammar(test_case1)

# Case 2: This test case parses and validates an input text that contains
#         multiple cases. Each case contains a variable assignment with a
#         numeric value.
# Expected behaviour.
# Output:  "The text provided is valid. LL(1) parsing:"
#           and the LL1 parsing tree
test_case2 = """match var_2:
    case 1:
        var = 1
    case 2:
        var = 2
    case _:
        var = 3
        """

parse_grammar(test_case2)

# Case 3: This test case parses and validates an input text that contains
#         multiple match-case blocks, with the first one containing a nested
#         match-case inside. Each case includes a variable assignment with a
#         numeric value.
# Expected behaviour.
# Output:  "The text provided is valid. LL(1) parsing:"
#           and the LL1 parsing tree
test_case3 = """match _varName1:
    case var1:
        match var_2:
            case 1:
                var = 1
            case 2:
                var = 2
            case _:
                var = 3
    case var2:
        var = 2
    case _:
        var = 3
        """

parse_grammar(test_case3)

# Case 4: This test case parses and validates an input text that contains
#         multiple match-case blocks. It also explores different
#         variable names.
# Expected behaviour.
# Output:  "The text provided is valid. LL(1) parsing:"
#           and the LL1 parsing tree
test_case4 = """match _varName_23:
    case var1:
        match var_2:
            case 1:
                match var_2:
                    case 1:
                        var = 1
                    case _:
                        var = 3
            case _:
                var = 3
    case var2:
        var = 2
    case _:
        var = 3
        """

parse_grammar(test_case4)

# Case 5: This test case parses and validates an input text that contains
#         multiple cases but lacks a default pattern.
# Expected behaviour.
# Output:  "The text provided is not valid. Unable to parse."
test_caseF1 = """match var_1:
    case 1:
        print('Path one')
    case 2:
        print('Path two')
    case 3:
        print('Path three')
        """

parse_grammar(test_caseF1)

# Case 6: This test case reveals a limitation of the implemented context-free
#         grammar: variable-to-variable assignment was not implemented.
# Limitation.
# Output: "The text provided is not valid. Unable to parse."
test_caseF2 = """match var_2:
    case 1:
        var = var1
    case 2:
        var = var2
    case _:
        var = var3
        """

parse_grammar(test_caseF2)

# Case 7: This test case parses and validates an input text that contains
#         multiple cases but a variable starts with a number instead of
#         an underscore or a letter.
# Expected behaviour.
# Output: "The text provided is not valid. Unable to parse."
test_caseF3 = """match 1varName:
    case var1:
        match var_2:
            case 1:
                var = 1
            case 2:
                var = 2
            case _:
                var = 3
    case var2:
        var = 2
    case _:
        var = 3
        """

parse_grammar(test_caseF3)

# Case 8: This test case exposes another limitation of the implemented
#         context-free grammar: the print function is restricted to having
#         only strings inside colons.
# Limitation.
# Output: "The text provided is not valid. Unable to parse."
test_caseF4 = """match _varName_23:
    case var1:
        match var_2:
            case 1:
                match var_2:
                    case 1:
                        var = 1
                    case _:
                        var = 3
            case _:
                var = 3
    case var2:
        print('22')
    case _:
        var = 323
        """

parse_grammar(test_caseF4)
